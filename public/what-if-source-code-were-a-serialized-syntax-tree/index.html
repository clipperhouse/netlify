<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>What if ‘source code’ were a serialized syntax tree? · Matt Sherman</title>

	
	<meta name="author" content="Matt Sherman">

	
	<link href="/css/normalize.f4d7e8250f8f124f8b7d087e5e260766a34b079fddc43e7b20d8c18ca1e92e51.css" rel="stylesheet">

	
	<link href="/css/skeleton.09b82130c4ba09fa45b20e9845ce089b8e1ad26a3b102e16901feea242e35ac1.css" rel="stylesheet">
	
	
	<link href="/css/style.cd4b94110b7f746a6dd1a59a487597411efb74de9fdaa558e166662737929adf.css" rel="stylesheet">
	
	
	

	<link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">
	<link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

</head>
<body>
	<header>
	<h4>
		<a href="https://clipperhouse.com">clipperhouse.com</a>
	</h4>
	<nav>
		<a href="/about/">about</a>
		<span class="sep">·</span>
		<a href="/jargon/">jargon</a>
		<span class="sep">·</span>
		<a href="/gen/overview/">gen</a>
		<span class="sep">·</span>
		<a href="/stack-correlations/">tag correlations</a>
	</nav>
</header>

	
	<main class="single">
		<article>
			<h1>What if ‘source code’ were a serialized syntax tree?</h1>
			<div>
				<p>At the risk of revealing my lack of a CompSci degree: what if ‘source code’ were replaced by serialized syntax trees?</p>
<p>What if the canonical ‘source’ of an application were not source code, as created by humans, but rather a serialized format of the syntax tree?</p>
<p>The workflow would go like this. You check out the repository. You make changes, and debug, to your satisfaction. Your <em>local</em> changes are still ‘source code’ as we currently understand it.</p>
<p>Then, instead of committing your changes, you feed your source code to the complier/interpreter, which creates a naive syntax tree. This syntax tree preserves the names of your symbols, and does no optimization.</p>
<p>The syntax tree is then decompiled into new source code, and written out. It is logically and semantically the identical to the original text, but style choices you may have made are swept away.</p>
<p>The generated source code is still meant for human consumption. It would need to preserve things like names and comments.</p>
<p>Among the things that are obviated: formatting, obviously, but also storage. The serialization includes rules for how the tree is persisted to disk.</p>
<p>It also means that changesets consist <strong>solely of logical &amp; semantic changes</strong>. Syntactic and formatting changes are eliminated. IDE’s could facilitate a lot of this. Heck, perhaps this process could happen <em>right inside source control</em>, with the appropriate plugins.</p>
<p>The idea would be to eliminate a class of friction within teams. Fewer subjective decisions.</p>
<p>(This might remind you of whitespace-significant languages, which are good for disposing of formatting arguments among programmers.)</p>
<p>I don’t doubt this would require a fair amount of work so that it functions for humans. My question is, is there a <em>logical</em> dealbreaker in this idea? I suspect it’s been attempted, and would love to hear stories.</p>
<p><a href="https://news.ycombinator.com/item?id=5490663">discuss on hacker news</a></p>
<p><em>Addendum: it didn’t take long for it to be pointed out that this is a thing, and that Lisp is the canonical example. So a further question: what human factors prevent it from becoming common?</em></p>

			</div>
		</article>
		<div class="post-meta">
			<p>—</p>
			<p>Published by Matt Sherman on April 4, 2013</p>
			<p>
				
					<a href="https://clipperhouse.com/alerts-as-spam/" class="prev">← Alerts as spam</a>
				
				
					<a href="https://clipperhouse.com/debugging-is-debugging/" class="next">Debugging is debugging →</a>
				
			</p>

		</div>
	</main>

	<footer>

</footer>

</body>

</html>
