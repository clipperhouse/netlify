<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Debugging is debugging" />
<meta property="og:description" content="I use CoffeeScript here and there. And JavaScript everywhere else.
Depending on the scenario, and this is a matter of taste, CoffeeScript is more elegant, readable, and usable.
When offering this notion, inevitably there is a complaint about “debugging.” CS is generating code, it’s a layer of abstraction, which will lead to frustration, etc.
The question is, compared to what? When JavaScript is not behaving as you wish, what do you do?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://clipperhouse.netlify.com/blog/debugging-is-debugging/" />



<meta property="article:published_time" content="2013-03-17T17:38:25&#43;00:00"/>

<meta property="article:modified_time" content="2013-03-17T17:38:25&#43;00:00"/>











<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Debugging is debugging"/>
<meta name="twitter:description" content="I use CoffeeScript here and there. And JavaScript everywhere else.
Depending on the scenario, and this is a matter of taste, CoffeeScript is more elegant, readable, and usable.
When offering this notion, inevitably there is a complaint about “debugging.” CS is generating code, it’s a layer of abstraction, which will lead to frustration, etc.
The question is, compared to what? When JavaScript is not behaving as you wish, what do you do?"/>
<meta name="generator" content="Hugo 0.40.3" />


    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Debugging is debugging",
  "url": "https://clipperhouse.netlify.com/blog/debugging-is-debugging/",
  "wordCount": "423",
  "datePublished": "2013-03-17T17:38:25&#43;00:00",
  "dateModified": "2013-03-17T17:38:25&#43;00:00",
  "author": {
    "@type": "Person",
    "name": ""
  }
}
</script>



    <link rel="canonical" href="https://clipperhouse.netlify.com/blog/debugging-is-debugging/">

    <title>Debugging is debugging | clipperhouse</title>

    <!-- combined, minified CSS -->
    <link href="https://clipperhouse.netlify.com/css/style.css" rel="stylesheet" integrity="sha384-TbfEhJn4HkgPUIZUhhHaAYsycYKHxSuIloCjZOiyCSpbVunRQxg5T5pxKVFwxilF" crossorigin="anonymous">

    

    

    

    

  </head>

  <body>

    
    <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link " href="https://clipperhouse.netlify.com/">Home</a>
        </nav>
      </div>
    </div>
    

    
    <header class="blog-header">
      <div class="container">
        <h1 class="blog-title"><a href="https://clipperhouse.netlify.com/" rel="home">clipperhouse</a></h1>
        
      </div>
    </header>
    

    
    <div class="container">
      <div class="row">
        <div class="col-sm-8 blog-main">

          


<article class="blog-post">
  <header>
    <h2 class="blog-post-title"><a href="https://clipperhouse.netlify.com/blog/debugging-is-debugging/">Debugging is debugging</a></h2>
    <p class="blog-post-meta"><time datetime="2013-03-17T17:38:25Z">Sun Mar 17, 2013</time> by </p>
  </header>
  <p>I use CoffeeScript <a href="https://github.com/clipperhouse/classicalrad.io">here</a> and <a href="https://github.com/clipperhouse/BetterBird">there</a>. And JavaScript everywhere else.</p>

<p>Depending on the scenario, and this is a matter of taste, CoffeeScript is more elegant, readable, and usable.</p>

<p>When offering this notion, inevitably there is a complaint about “debugging.” CS is generating code, it’s a layer of abstraction, which will lead to frustration, etc.</p>

<p>The question is, compared to what? When JavaScript is not behaving as you wish, what do you do?</p>

<p>You debug it. You log, you hit breakpoints, and most importantly, you build a mental model of how the program is behaving.</p>

<p>Did you learn about truthiness and ‘this’ in JS by <em>logic</em>? Ex post facto maybe. But you debugged your way to that understanding.</p>

<p>CoffeeScript is identical in this regard. It has syntax, and semantics. You write code, see what it does, change it, see what it does. You build a mental model.</p>

<p>CoffeeScript doesn’t make a program easier to debug; it also doesn’t make it harder. Semantics. Behavior. Mental model. Rinse and repeat.</p>

<p>What CoffeeScript does do, in my experience, it make trivial debugging less likely.</p>

<p>Because it’s whitespace-significant, you are unlikely to miss a closing brace. Because it has sensible iterators, you are not going to fuck it up Google it for the 50th time. Because it has ?, you are not going to choose among false, falsy, null, undefined, typeof, instanceof. For the 50th time.</p>

<p>Maybe I’m projecting. I am sure you’re adept with the above issues. You’ve memorized them over time, hammered JS’s behaviors into your head, experimented and built a robust mental model. Which is great!</p>

<p>But there might be a bit of <a href="http://www.youtube.com/watch?v=ekeELle5g-o"><em>challenge accepted</em></a> in there, if we’re honest. JS is tedious and idiosyncratic — which is how normals see programming in general. Our ability to reason through that stuff to make something useful is where we derive our reward.</p>

<p>For me, and more so over time, shipping is where I derive my reward. Correctness is rewarding. Code that looks like what it does, is rewarding. So CoffeeScript, for me, is rewarding.</p>

<p>—</p>

<p>A couple of addenda — in terms of the ‘taste’ thing, I’ve settled on CS on the server (if using node) and plain JS on the client. The difference is that the latter requires a build step while the former does not. coffee app.coffee just works, no hint of JS.</p>

<p>And source maps are a nice tool, so I can imagine that objection to the CS abstraction. Looks like CS got <a href="http://coffeescript.org/#source-maps">support</a> for that as well, but haven’t yet tried it.</p>


  

  
  <hr>
  <footer>

  
    <section>
    <h4>Share</h4>
    <nav class="nav sharing-icons">
      <a class="nav-item" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fclipperhouse.netlify.com%2fblog%2fdebugging-is-debugging%2f" title="Share on Facebook"><span class="fa fa-facebook fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://plus.google.com/share?url=https%3a%2f%2fclipperhouse.netlify.com%2fblog%2fdebugging-is-debugging%2f" title="Share on Google+"><span class="fa fa-google-plus fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fclipperhouse.netlify.com%2fblog%2fdebugging-is-debugging%2f" title="Share on LinkedIn"><span class="fa fa-linkedin fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://twitter.com/home?status=https%3a%2f%2fclipperhouse.netlify.com%2fblog%2fdebugging-is-debugging%2f" title="Tweet this"><span class="fa fa-twitter fa-2x"></span></a>
    </nav>
  </section>

  

  
  </footer>
  

</article> 



        </div> <!-- /.blog-main -->

        <aside class="col-sm-3 ml-auto blog-sidebar">
  

  

  
</aside>


      </div> <!-- /.row -->
    </div> <!-- /.container -->
    

    
    <footer class="blog-footer">
      <p>
      
      Blog template created by <a href="https://twitter.com/mdo">@mdo</a>, ported to Hugo by <a href='https://twitter.com/mralanorth'>@mralanorth</a>.
      
      </p>
      <p>
      <a href="#">Back to top</a>
      </p>
    </footer>
    

  </body>

</html>
