<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <title>Imagining version control for APIs - clipperhouse</title>
  
  <meta name="description" content="Versioning is, right now, merely a human label. We have helpful conventions like semver, but one still relies on human judgment as to the definition of a ‚Äúnotable‚Äù change.
What if the machine could detect, and perhaps describe, API changes in a meaningful way?
What I imagine is this: a program that examines a program‚Äôs API for changes, and describes them. Version control, in other words, of the sort we expect from Git.">
  <meta name="author" content="">
  
  <link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700,700i" rel="stylesheet">
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
  <link href="/css/style.css" rel="stylesheet">
  
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  
  <meta name="generator" content="Hugo 0.40.3">
  
  <link rel="alternate" type="application/atom+xml" href="/index.xml" title="clipperhouse">
</head>
<body class="single">
  <header class="header">
    
    <p class="title"><a href="/"><span>üç±</span>clipperhouse</a></p>
    
    <button class="menu-toggle" type="button"></button>
    <nav class="menu">
      <ul>
        
        
      </ul>
    </nav>
  </header>
  <main class="main">

<article class="post post-view">
  <header class="post-header">
    <h1 class="post-title">Imagining version control for APIs</h1>
    <p class="post-meta">2015.12.21</p>
  </header>
  <div class="post-content">

<p>Versioning is, right now, merely a human label. We have helpful conventions like <a href="http://semver.org/">semver</a>, but one still relies on human judgment as to the definition of a ‚Äúnotable‚Äù change.</p>

<p>What if the machine could detect, and perhaps describe, API changes in a meaningful way?</p>

<p>What I imagine is this: a program that examines a program‚Äôs API for changes, and describes them. Version control, in other words, of the sort we expect from Git.</p>

<p>Instead of a whole program being described as a version, <strong>each callable API</strong> (endpoint, method, etc) gets its <em>own</em> version. We, the consumer, know when Foo() has changed while Bar() has not; API versioning becomes granular.</p>

<h4 id="black-box">Black box</h4>

<p>One way me might go about this is black box versioning, by which I mean the versioner can <strong>interact</strong> with an API, but knows nothing of its underlying implementation.</p>

<p>In this case, the versioner would be an extension of the test suite. This versioner could only provide the guarantees that the test suite does.</p>

<p>Most tests are necessarily finite and incomplete; they are as good as the test writer‚Äôs imagination. We don‚Äôt (can‚Äôt) write tests for every possible input, and so the programmers choose representative cases.</p>

<p>Such a system could prove the existence of changes, but could not prove the absence of changes. There is also the meta-issue that the tests themselves would need to be versioned.</p>

<p>Even with such limitations, it would be a substantial improvement over the status quo of human-imagined ‚Äúversions‚Äù.</p>

<h4 id="white-box">White box</h4>

<p>This gets interesting. What if the versioner didn‚Äôt simply call the API as an outsider, but could inspect the <strong>source code</strong> comprising the API?</p>

<p>In this case, we could bring static analysis to bear and provide more guarantees. Instead of calling the API looking for an exceptional case, we analyze the source code to detect semantic changes.</p>

<p>Is there a form of static analysis that transforms source code into a normalized representation, such that two semantically identical programs with different source can be proved identical?</p>

<p>I don‚Äôt know the answer, which is one reason I am writing this post. (Would love your feedback on <a href="https://news.ycombinator.com/item?id=10769073">HN</a> or <a href="https://twitter.com/clipperhouse">Twitter</a>.)</p>

<p>One representation that comes to mind is <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a>‚Ää‚Äî‚Ääcould it identify some classes of semantically identical programs? What about the various forms of IR in compiler front ends or back ends (LLVM, etc)?</p>

<p>Such a versioner would likely need to be language specific (though perhaps it could exploit common IR‚Äôs like LLVM).</p>

<h4 id="conclusion">Conclusion</h4>

<p>This really intrigues me and I haven‚Äôt come across logical show-stoppers yet. Such a system would only need to be an improvement over the status quo, but not perfect.</p>

<p>That said, I would love to see real, Git-like versioning of API semantics. This would be especially helpful in the world of dependency management‚Ää‚Äî‚Ääwhere versioning is a particularly intractable bear.</p>
</div>
  <footer class="post-footer">
    
  </footer>
  
  
  
  
</article>
</main>
<footer class="footer">
  <span>&copy; 2017-2018 clipperhouse üéâ</span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" target="_blank">Hugo‚ù§Ô∏èÔ∏è</a></span>
  <span>&middot;</span>
  <span>Designed by <a href="http://21beats.com/" target="_blank">Ô∏è21beats‚ö°Ô∏è</a></span>
</footer>
<script src="https://cdn.bootcss.com/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  hljs.initHighlightingOnLoad();
  menuToggle();
  InstantClick.on('change', function() {
    var blocks = document.querySelectorAll('pre code');
    for (var i = 0; i < blocks.length; i++) {
      hljs.highlightBlock(blocks[i]);
    }
    menuToggle();
  });
  function menuToggle() {
    var $toggle = document.querySelector('.menu-toggle');
    if (!$toggle.offsetParent) {
      return;
    }
    var $body = document.querySelector('body');
    $toggle.addEventListener('click', function() {
      $body.classList.toggle('noscroll');
    }, false);
  }
</script>
</body>
</html>

