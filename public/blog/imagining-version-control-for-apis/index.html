<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site  | Imagining version control for APIs</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.40.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.ab4b67a3ea25990fa8279f3b7ef08b61.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="Imagining version control for APIs" />
<meta property="og:description" content="Versioning is, right now, merely a human label. We have helpful conventions like semver, but one still relies on human judgment as to the definition of a “notable” change.
What if the machine could detect, and perhaps describe, API changes in a meaningful way?
What I imagine is this: a program that examines a program’s API for changes, and describes them. Version control, in other words, of the sort we expect from Git." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/blog/imagining-version-control-for-apis/" />



<meta property="article:published_time" content="2015-12-21T00:49:04&#43;00:00"/>

<meta property="article:modified_time" content="2015-12-21T00:49:04&#43;00:00"/>











<meta itemprop="name" content="Imagining version control for APIs">
<meta itemprop="description" content="Versioning is, right now, merely a human label. We have helpful conventions like semver, but one still relies on human judgment as to the definition of a “notable” change.
What if the machine could detect, and perhaps describe, API changes in a meaningful way?
What I imagine is this: a program that examines a program’s API for changes, and describes them. Version control, in other words, of the sort we expect from Git.">


<meta itemprop="datePublished" content="2015-12-21T00:49:04&#43;00:00" />
<meta itemprop="dateModified" content="2015-12-21T00:49:04&#43;00:00" />
<meta itemprop="wordCount" content="469">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Imagining version control for APIs"/>
<meta name="twitter:description" content="Versioning is, right now, merely a human label. We have helpful conventions like semver, but one still relies on human judgment as to the definition of a “notable” change.
What if the machine could detect, and perhaps describe, API changes in a meaningful way?
What I imagine is this: a program that examines a program’s API for changes, and describes them. Version control, in other words, of the sort we expect from Git."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://example.org/" class="f3 fw2 hover-white no-underline white-90 dib">
      My New Hugo Site
    </a>
    <div class="flex-l items-center">
      
      








    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <article class="flex-l flex-wrap justify-between mw8 center">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        BLOGS
      </p>
      <h1 class="f1 athelas mb1">Imagining version control for APIs</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2015-12-21T00:49:04Z">December 21, 2015</time>
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<p>Versioning is, right now, merely a human label. We have helpful conventions like <a href="http://semver.org/">semver</a>, but one still relies on human judgment as to the definition of a “notable” change.</p>

<p>What if the machine could detect, and perhaps describe, API changes in a meaningful way?</p>

<p>What I imagine is this: a program that examines a program’s API for changes, and describes them. Version control, in other words, of the sort we expect from Git.</p>

<p>Instead of a whole program being described as a version, <strong>each callable API</strong> (endpoint, method, etc) gets its <em>own</em> version. We, the consumer, know when Foo() has changed while Bar() has not; API versioning becomes granular.</p>

<h4 id="black-box">Black box</h4>

<p>One way me might go about this is black box versioning, by which I mean the versioner can <strong>interact</strong> with an API, but knows nothing of its underlying implementation.</p>

<p>In this case, the versioner would be an extension of the test suite. This versioner could only provide the guarantees that the test suite does.</p>

<p>Most tests are necessarily finite and incomplete; they are as good as the test writer’s imagination. We don’t (can’t) write tests for every possible input, and so the programmers choose representative cases.</p>

<p>Such a system could prove the existence of changes, but could not prove the absence of changes. There is also the meta-issue that the tests themselves would need to be versioned.</p>

<p>Even with such limitations, it would be a substantial improvement over the status quo of human-imagined “versions”.</p>

<h4 id="white-box">White box</h4>

<p>This gets interesting. What if the versioner didn’t simply call the API as an outsider, but could inspect the <strong>source code</strong> comprising the API?</p>

<p>In this case, we could bring static analysis to bear and provide more guarantees. Instead of calling the API looking for an exceptional case, we analyze the source code to detect semantic changes.</p>

<p>Is there a form of static analysis that transforms source code into a normalized representation, such that two semantically identical programs with different source can be proved identical?</p>

<p>I don’t know the answer, which is one reason I am writing this post. (Would love your feedback on <a href="https://news.ycombinator.com/item?id=10769073">HN</a> or <a href="https://twitter.com/clipperhouse">Twitter</a>.)</p>

<p>One representation that comes to mind is <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> — could it identify some classes of semantically identical programs? What about the various forms of IR in compiler front ends or back ends (LLVM, etc)?</p>

<p>Such a versioner would likely need to be language specific (though perhaps it could exploit common IR’s like LLVM).</p>

<h4 id="conclusion">Conclusion</h4>

<p>This really intrigues me and I haven’t come across logical show-stoppers yet. Such a system would only need to be an improvement over the status quo, but not perfect.</p>

<p>That said, I would love to see real, Git-like versioning of API semantics. This would be especially helpful in the world of dependency management — where versioning is a particularly intractable bear.</p>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy; 2018 My New Hugo Site
  </a>
  








  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
