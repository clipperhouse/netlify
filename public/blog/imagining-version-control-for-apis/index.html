<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Imagining version control for APIs" />
<meta property="og:description" content="Versioning is, right now, merely a human label. We have helpful conventions like semver, but one still relies on human judgment as to the definition of a “notable” change.
What if the machine could detect, and perhaps describe, API changes in a meaningful way?
What I imagine is this: a program that examines a program’s API for changes, and describes them. Version control, in other words, of the sort we expect from Git." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://clipperhouse.netlify.com/blog/imagining-version-control-for-apis/" />



<meta property="article:published_time" content="2015-12-21T00:49:04&#43;00:00"/>

<meta property="article:modified_time" content="2015-12-21T00:49:04&#43;00:00"/>











<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Imagining version control for APIs"/>
<meta name="twitter:description" content="Versioning is, right now, merely a human label. We have helpful conventions like semver, but one still relies on human judgment as to the definition of a “notable” change.
What if the machine could detect, and perhaps describe, API changes in a meaningful way?
What I imagine is this: a program that examines a program’s API for changes, and describes them. Version control, in other words, of the sort we expect from Git."/>
<meta name="generator" content="Hugo 0.40.3" />


    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Imagining version control for APIs",
  "url": "https://clipperhouse.netlify.com/blog/imagining-version-control-for-apis/",
  "wordCount": "469",
  "datePublished": "2015-12-21T00:49:04&#43;00:00",
  "dateModified": "2015-12-21T00:49:04&#43;00:00",
  "author": {
    "@type": "Person",
    "name": ""
  }
}
</script>



    <link rel="canonical" href="https://clipperhouse.netlify.com/blog/imagining-version-control-for-apis/">

    <title>Imagining version control for APIs | clipperhouse</title>

    <!-- combined, minified CSS -->
    <link href="https://clipperhouse.netlify.com/css/style.css" rel="stylesheet" integrity="sha384-TbfEhJn4HkgPUIZUhhHaAYsycYKHxSuIloCjZOiyCSpbVunRQxg5T5pxKVFwxilF" crossorigin="anonymous">

    

    

    

    

  </head>

  <body>

    
    <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link " href="https://clipperhouse.netlify.com/">Home</a>
        </nav>
      </div>
    </div>
    

    
    <header class="blog-header">
      <div class="container">
        <h1 class="blog-title"><a href="https://clipperhouse.netlify.com/" rel="home">clipperhouse</a></h1>
        
      </div>
    </header>
    

    
    <div class="container">
      <div class="row">
        <div class="col-sm-8 blog-main">

          


<article class="blog-post">
  <header>
    <h2 class="blog-post-title"><a href="https://clipperhouse.netlify.com/blog/imagining-version-control-for-apis/">Imagining version control for APIs</a></h2>
    <p class="blog-post-meta"><time datetime="2015-12-21T00:49:04Z">Mon Dec 21, 2015</time> by </p>
  </header>
  

<p>Versioning is, right now, merely a human label. We have helpful conventions like <a href="http://semver.org/">semver</a>, but one still relies on human judgment as to the definition of a “notable” change.</p>

<p>What if the machine could detect, and perhaps describe, API changes in a meaningful way?</p>

<p>What I imagine is this: a program that examines a program’s API for changes, and describes them. Version control, in other words, of the sort we expect from Git.</p>

<p>Instead of a whole program being described as a version, <strong>each callable API</strong> (endpoint, method, etc) gets its <em>own</em> version. We, the consumer, know when Foo() has changed while Bar() has not; API versioning becomes granular.</p>

<h4 id="black-box">Black box</h4>

<p>One way me might go about this is black box versioning, by which I mean the versioner can <strong>interact</strong> with an API, but knows nothing of its underlying implementation.</p>

<p>In this case, the versioner would be an extension of the test suite. This versioner could only provide the guarantees that the test suite does.</p>

<p>Most tests are necessarily finite and incomplete; they are as good as the test writer’s imagination. We don’t (can’t) write tests for every possible input, and so the programmers choose representative cases.</p>

<p>Such a system could prove the existence of changes, but could not prove the absence of changes. There is also the meta-issue that the tests themselves would need to be versioned.</p>

<p>Even with such limitations, it would be a substantial improvement over the status quo of human-imagined “versions”.</p>

<h4 id="white-box">White box</h4>

<p>This gets interesting. What if the versioner didn’t simply call the API as an outsider, but could inspect the <strong>source code</strong> comprising the API?</p>

<p>In this case, we could bring static analysis to bear and provide more guarantees. Instead of calling the API looking for an exceptional case, we analyze the source code to detect semantic changes.</p>

<p>Is there a form of static analysis that transforms source code into a normalized representation, such that two semantically identical programs with different source can be proved identical?</p>

<p>I don’t know the answer, which is one reason I am writing this post. (Would love your feedback on <a href="https://news.ycombinator.com/item?id=10769073">HN</a> or <a href="https://twitter.com/clipperhouse">Twitter</a>.)</p>

<p>One representation that comes to mind is <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> — could it identify some classes of semantically identical programs? What about the various forms of IR in compiler front ends or back ends (LLVM, etc)?</p>

<p>Such a versioner would likely need to be language specific (though perhaps it could exploit common IR’s like LLVM).</p>

<h4 id="conclusion">Conclusion</h4>

<p>This really intrigues me and I haven’t come across logical show-stoppers yet. Such a system would only need to be an improvement over the status quo, but not perfect.</p>

<p>That said, I would love to see real, Git-like versioning of API semantics. This would be especially helpful in the world of dependency management — where versioning is a particularly intractable bear.</p>


  

  
  <hr>
  <footer>

  
    <section>
    <h4>Share</h4>
    <nav class="nav sharing-icons">
      <a class="nav-item" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fclipperhouse.netlify.com%2fblog%2fimagining-version-control-for-apis%2f" title="Share on Facebook"><span class="fa fa-facebook fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://plus.google.com/share?url=https%3a%2f%2fclipperhouse.netlify.com%2fblog%2fimagining-version-control-for-apis%2f" title="Share on Google+"><span class="fa fa-google-plus fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fclipperhouse.netlify.com%2fblog%2fimagining-version-control-for-apis%2f" title="Share on LinkedIn"><span class="fa fa-linkedin fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://twitter.com/home?status=https%3a%2f%2fclipperhouse.netlify.com%2fblog%2fimagining-version-control-for-apis%2f" title="Tweet this"><span class="fa fa-twitter fa-2x"></span></a>
    </nav>
  </section>

  

  
  </footer>
  

</article> 



        </div> <!-- /.blog-main -->

        <aside class="col-sm-3 ml-auto blog-sidebar">
  

  

  
</aside>


      </div> <!-- /.row -->
    </div> <!-- /.container -->
    

    
    <footer class="blog-footer">
      <p>
      
      Blog template created by <a href="https://twitter.com/mdo">@mdo</a>, ported to Hugo by <a href='https://twitter.com/mralanorth'>@mralanorth</a>.
      
      </p>
      <p>
      <a href="#">Back to top</a>
      </p>
    </footer>
    

  </body>

</html>
