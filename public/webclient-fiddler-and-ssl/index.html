<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>WebClient, Fiddler and SSL</title>
	
	<meta name="author" content="Matt Sherman">

	
	<link href="/css/normalize.f4d7e8250f8f124f8b7d087e5e260766a34b079fddc43e7b20d8c18ca1e92e51.css" rel="stylesheet">

	
	<link href="/css/skeleton.09b82130c4ba09fa45b20e9845ce089b8e1ad26a3b102e16901feea242e35ac1.css" rel="stylesheet">
	
	
	<link href="/css/style.957ee09559919d8fb5774e0ff59d59fc278d5e52eeccd0f93c4dbabddc248176.css" rel="stylesheet">
	
	
	

	<link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">
	<link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

</head>
<body>
	<header>
	<h4>
		<a href="https://clipperhouse.com">clipperhouse.com</a>
	</h4>
	<nav>
		<a href="/about/">about</a>
		<span class="sep">·</span>
		<a href="/jargon/">jargon</a>
		<span class="sep">·</span>
		<a href="/gen/overview/">gen</a>
		<span class="sep">·</span>
		<a href="/stack-correlations/">tag correlations</a>
	</nav>
</header>

	
	<main class="single">
		<article>
			<h1>WebClient, Fiddler and SSL</h1>
			<div>
				<p>I am developing a credit card authorization library which uses the <a href="http://msdn.microsoft.com/en-us/library/system.net.webclient.aspx">WebClient</a> class. In addition, I am using the excellent <a href="http://www.fiddler2.com">Fiddler</a> to watch the requests and responses.</p>
<p>As you might expect, the credit card web service is HTTPS. Fiddler is acting as a proxy server on my dev machine.</p>
<p>Not surprisingly, WebClient throws an exception: “The underlying connection was closed: Could not establish secure channel for SSL/TLS”. As well it should — the SSL certificate in this case is not the one supplied by credit card authorizer. Fiddler is intercepting the request and issuing its own dummy certificate, as it must.</p>
<p>So we’ve got a man-in-the-middle, and WebClient doesn’t like it. What to do?</p>
<p>Turns out there is a way of telling System.Net to allow invalid certificates to pass. Here’s the code.</p>
<p>[code:c#]using System.Net;<br>
using System.Net.Security;<br>
using System.Security.Cryptography.X509Certificates;<br>
using System.Web;</p>
<p>public static class Network<br>
{<br>
public static void AllowInvalidCertificate()<br>
{<br>
if (HttpContext.Current.Request.Url.Host == “localhost”)<br>
{<br>
ServicePointManager.ServerCertificateValidationCallback += new RemoteCertificateValidationCallback(allowCert);<br>
}<br>
}</p>
<p>private static bool allowCert(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors error)<br>
{<br>
return true;<br>
}<br>
}<br>
[/code]</p>
<p>I implemented it as a static class so when I need it in my code I just call Network.AllowInvalidCertificate(). Now my WebClient requests work without throwing an Exception, and Fiddler is able to show me those requests so I can debug.</p>
<p>Do I need to tell you that this is a security risk, so be careful? We’re disabling one of the fundamental purposes of SSL.</p>
<p>In my case, you’ll notice I check for localhost first, to reduce the risk that this gets called on a production site. You’ll want to put your own precautions in there as well.</p>
<p>Sources:</p>

			</div>
		</article>
		<p class="post-meta">Published by Matt Sherman on May 1, 2009. <a href="https://mobile.twitter.com/clipperhouse">Find me at @clipperhouse</a>.
		</p>			
	</main>

	<footer>
	<p>&copy; 2020</p>
</footer>

</body>

</html>
